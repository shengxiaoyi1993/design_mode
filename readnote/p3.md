# 3 创建型模式

- 抽象了实例化过程，使系统独立于创建、组合和表示对象
- 类创建模式：使用继承
- 对象创建模式：将实例化委托给一个类
- 定义一个较小的行为集，这些行为可以任意组合为更复杂的行为 

- 特征：封装使用的类的信息；隐藏类是如何被创建和放在一起的 类的创建位置/时间/方式/创建者都有很大灵活性



## 3.1 abstract factory（抽象工厂） 对象创建模式

- 意图
  
  - 创建一系列相关或者相互依赖的对象的接口，而无需指定具体的类
- 别名：kit
- 动机：支持不同视感风格的界面；客户仅与抽象类定义的接口交互，而不使用特定的具体类的接口
- 适用性：
  - 系统独立于产品的创建、组合和表示
  - 系统由多个产品系列中的一个来配置
  - 强调一系列相关的产品对象的设计
  - 提供产品类库，只想提供接口而非实现
- 结构
- 参与者
- 协作：运行时刻创建一个concreteFactroy实例，由该工厂创建由特定实现的产品
- 效果
  - 分离具体类
  - 便于交换产品系列
  - 利于产品一致型
  - 难以支持新产品 ：支持新产品需要拓展抽象类及其子类的接口
- 实现
  - 工厂作为单件
  - 创建产品  每个产品一个工厂方法，即使差别很小；也可以用prototype模式，用产品的原型创建新的工厂，支持多个可能的产品系列
  - 定义可拓展的工厂 
    - 添加参数 不安全
- 实例

  

## 3.2 builder 

- 意图

  - 将复杂对象的构建与表示分离，使相同的构建过程可以创建不同的表示
  - //表示程序调用一个转换器（或解释器），而这一转换器有多种子类实现，从而能表示出多种风格

- 动机

  - 转换多种风格

- 适用性

  - 当复杂对象的算法应该独立于该对象的组成部分与他们的装配方式
  - 当构造过程必须允许被构造的对象由不同的表示时

- 结构

  - builder有相同父类接口，多种子类实现
  - director调用相同的结构和不同的子类实现，获得不同的表示

- 参与者

  - Builder
  - ConcreteBuilder 
  - director 
  - product 

  

- 协作

  

- 效果

  - 可以改变产品的内部表示：提供的是生成器的接口，实现过程被隐藏，通过增加生成器来定义新产品
  - 构造代码和表示代码分开
  - 对构造过程实现更精细的控制：指的是director调用buiilder生成产品的过程

- 实现

  - 抽象的builder类定义所有操作，缺省情况下什么都不做。concrete有兴趣时重定义该操作
    - 装配和构造接口：接口足够普遍；builder有时会用到已经生成的产品，就需要由director回传给builder
    - 为什么产品没有抽象类：产品间的差别可能很大
    - 故意不声明为纯虚函数而只是定义为空，使得concretebuilder只需要重定义感兴趣的操作

- 实例

  - 

- 应用

  - 自适应通讯环境

- 相关模式

  - abstract factory 着重于多个系列的产品或对象
  - builder着重于构造对象的步骤



## 3.3 factory method 

- 意图

  - 定义一个用于创建对象的类，让子类决定实例化哪一个类
  - factory使一个类的实例化延迟到子类

- 别名

  - 虚构造器

- 动机

  - 框架使用抽象类定义和维护对象之间的关系，也负责对象的创建

- 适用性

  - 一个类不知道他所创建的对象的类
  - 一个类希望由其子类指定它所创建的对象

- 结构

- 参与者

  - product
  - concreteproduct 
  - creator 
  - concretecreator 

- 协作

  - 依赖子类定义工厂方法

- 效果

  - 不再将与特定应用有关的类绑定到代码中
  - 可能为了一个特定的concrete对象创建creator的子类

  - 为子类提供挂钩
  - 连接平行的类层次

- 实现

  - 有缺省的工厂方法实现和没有的
  - 参数化工厂方法
  - 特定语言的变化
  - 使用模板以避免创建子类
  - 命名约定

- 实例
- 应用
- 相关
  - abstract 经常由工厂方法实现
  - 常在template method 中被调用



## 3.4 prototype 

- 意图
  - 用原型实例指定对象创建的种类，并且通过拷贝创建新的对象
- 动机
  - 使用框架操作不同类时，框架不知道如何创建具体的对象；对每个类创建子类是不合理的
  - 通过可通子类的实例来创建对象可以解决以上问题
  - 减少类的数量；便于增加新的类

- 适用性
  - 系统独立于他的产品创建，构成和表示
  - 要实例化的类在运行时刻指定
  - 避免创建一个与产品层次平行的工厂类层次
  - 一个类只能有有限的状态组合中的一种

- 结构

- 参与者

  - prototype 声明一个克隆自身的接口
  - concreteprototype 实现一个克隆自身的操作
  - client 让一个原型克隆自身从而创建一个新的对象

- 协作

  - 客户请求一个原型克隆自身

- 效果

  - 对客户隐藏了具体的产品类，使用户无需改变即可使用于特定应用相关的类
  - 运行时刻增加和删除产品
  - 改变值以指定新对象
  - 改变结构以指定新对象
  - 减少子类的构造
  - 用类动态配置应用
  - 缺陷：为某个类实现克隆可能很困难

- 实现

  - 使用原型管理器 保持一个可用原型的注册表；关联存储器，通过关键字注册原型或者解除注册；运行时可浏览或者修改

  - 实现克隆操作 深拷贝与浅拷贝

  - 初始化克隆对象 克隆后马上使用/或者调用initialize操作来初始化

    

- 实例

  - 用具体的对象实例化一个类，并作为成员变两保存在类内部，调用成员变量来进行构建
  - 成员变量的类型是他的父类，但实际上指向的是一个有具体操作的子类

- 应用

- 相关模式

  - abstract factory 具有类似的功能，也可以一起使用。如abstract factory储存一个被克隆的集合，并返回对象



```
- 意图
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 实例
- 应用
```
