# 5 行为模式

- 算法和对象职责的分配
- 控制流， 联系方式
- 行为对象模式使用组合而不是继承 相互协作/相互联系/耦合关系/依赖关系/

封装行为并指派/





## 5.1 chain of responsibility 

- 意图
  
  - 使多个对象有机会处理请求，避免耦合关系。将对象连成链，并沿着链传递该请求，直到有对象处理该请求
- 别名
- 动机
  
  - 同上
- 适用性
  - 多个对象可以处理同一请求，运行时刻自动确定
  - 不明确指定接收者时，可以向多个对象中的一个提交请求
  - 处理请求的集合应被动态指定
- 结构
  
  - 后继者作为接一个接收者
- 参与者
  - handler
  - concretehandler
  - client 
- 协作
  
  - 当客户提交一个请求时，请求沿链传递直至由一个concretehandler对象负责处理它
- 效果
  - 降低耦合度
  - 增强对象指派任务的灵活性
  - 不保证被接受
- 实现
  - 实现后继者链  
  - 连接后继者 转发给后继者 
  - 表示请求 定义请求的类型和处理方法，及请求者与处理者如何达成一致 （标示符与请求提供标示符函数）；子类可以通过重定义该函数拓展操作
- 实例
- 应用
- 相关模式

- 其他：

  - 职责链模式不由自身创建，而是由客户端进行设置
  - 一般的解决方法是边界各个层次的函数进行处理，需要修改时需要修改原代码，违反开闭原则

  

## 5.2 command 

- 意图
  - 将请求封装为对象，用不同的请求对客户进行参数化
- 别名
  - action transaction
- 动机
  - 接收者知道信息，该信息（可能是函数）是执行命令所需要的，将命令作为参数传入
  - 设计用户界面时具有很大灵活性
- 适用性
  - 抽象出待执行的行为以参数化某对象 回调函数面向对象的替代品
  - 在不同时刻指定、排列和执行请求
  - 支持取消操作
  - 支持修改日志
  - 用构建在原语基础上的高层操作构造一个系统   支持事务，易于拓展，添加新事务
- 结构
  - 支持取消操作
- 参与者
  - command 
  - concreteCommand
  - client
  - invoker
  - receiver
- 协作
  - client创建一个concreteCommand并指定他的receiver
  - invoker存储concretecommand对象
  - invoker提交请求，若命令可撤销，在执行之前
- 效果
  - 将操作对象 与 实现该操作对象向解耦   （？行为与信息分离）
  - 操作对象可与其他对象一样被操纵和拓展
  - 多个命令装配成一个复合命令
- 实现
  - 命令对象的智能程度 
  - 支持取消和操作  此时command需要记录额外的信息
  - 避免取消操作过程中的错误积累
  - 使用c++模板
- 实例
- 应用
  - 结合chain of responsibility，消费链
  - 命令的对象被计算出来，优化方法
- 相关模式
  - composite实现宏命令
  - memento 

## 5.3 interpreter 

- 意图
  - 给定语句，定义文法的一种表示，解释器解释该语句
- 别名
  - 
- 动机
  - 某种类型的问题发生频率足够高，将各个实例表述为简单语言中的句子。这样就可以通过解释这个句子来解决问题
- 适用性
  - 当有一个语言需要执行，并可以将该语言中的句子表示为一个抽象语法树，可使用解释器模式
  - 闻法简单
  - 效率不关键 最高效的解释器不直接解释语法分析树，而是首先转换成另外一种形式（状态机）
- 结构
- 参与者
  - abstractExpression 抽象表达式，声明一个抽象的解释操作
  - TerminalExpression 终结符表达式
  - NonterminalExpression 非终结符表达式
  - Context  上下文 
  - Client  客户
- 协作
  - client构建一个句子，初始化上下文，调用解释操作
  - 每一非终结符表达式定义相应子表达式的解释操作。各终结符表达式的解释操作构成递归的基础
  - 每一节点的解释操作用上下文来存储和访问解释器的状态
- 效果
  - 易于改变和拓展文法
  - 易于实现文法
  - 复杂文法难以维护   每条规则至少定义一个类，因此包含很多语法的文法可能难以管理和维护
  - 增加新的解释表达式的方法 若需要经常用新的方式解释表达式，则需要使用其他方式如访问者模式以避免修改这些表示文法的类
- 实现
  - 创建抽象语法树  不涉及语法分析，用语法分析程序/手写/client提供
  - 定义解释操作  并不需要在表达式中定义解释操作
  - 与Flyweight共享终结符 终结节点通常不保存位置信息，所需要的上下文信息由父节点传递给它们。用到了Flyeweight模式
- 实例
  - 通过lookup在预先设置的表上找到项与值，然后进行计算
- 应用
  - 大量使用，严格情况下，只有用一个类层次来定义某个语言时，才强调使用解释器模式
- 相关模式
  - composite:语法抽象树是复合模式的实例
  - Flyweight:说明了如何在抽象语法树中使用终结符



## 5.4 iterator 

- 意图

  - 提供一种按顺序访问一个聚合中的元素的方法，而不暴露内部表示

- 别名

  - cursor

- 动机

  - 见意图
  - 迭代器与列表分离，可以使用不同的遍历策略或者实现过滤规则

- 适用性

- 结构

- 参与者

  - iterator
  - concreteiterator 
  - aggregate
  - concreteaggregate

- 协作

  - 跟踪集合中的当前对象，能够计算出待遍历的后继对象

- 效果

  - 支持以不同方式遍历一个聚合

  - 简化了聚合的接口

  - 在同一各上可以同时由多个遍历 迭代器保存遍历状态

    

- 实现

  - 由谁控制迭代 外部迭代器/内部迭代器
  - 由谁实现遍历算法
  - 健壮性如何 保证插入和删除操作不会干扰遍历操作，且不需要拷贝该聚合
  - 附加的操作 
  - 在c++中使用多态迭代器 可能会删除出错
  - 迭代器可有特权访问 声明为protect ，其他迭台器继承该迭代器来进行拓展
  - 空迭代器 处理边界条件 

- 实例

  - 列表和迭代器接口
  - 迭代器子类的实现
  - 使用迭代器
  - 避免限定于一种特定的列表实现
  - 保证迭代器被删除 使用智能指针
  - 一个内部的ListIterator 由迭代器控制迭代，并对每个元素施行某个操作 传递全局函数；依赖于子类生成

- 应用

- 相关模式

  - composite iterator常用于复合结构
  - factorymethod:多态结构，通过factorymethod来实例化适当的迭代器子类

## 5.5 mediator 



- 意图
  - 封装一系列的对象交互 使各个对象不需要显式地相互引用从而使其耦合松散
- 别名
- 动机
  - 面向对象方法将行为分散到对象中，但会导致对象间的行为激增。   mediator能进行通信地中转
- 适用性
  - 定义良好，但是通信复杂 依赖关系混乱
  - 一个对象引用其他很多对象，导致该对象难以复用
  - 定制一个分布在多个类中的行为，又不想生成太多的类
- 结构
  - mediator
    - 中介者接口定义一个接口与各同事类的对象通信
  - concretemediator 
    - 中介者通过协调各同事对象实现协调行为
    - 了解和维护他的同事
  - colleague class 
    - 每个同事类知道它的中介者对象
    - 每个同事类需与其他的同事类进行通信时，与他的中介者通信
- 参与者
- 协作
  - 同事项一个中介者发送和接受请求，中介者在各个同事间适当地转发，以实现协作行为
- 效果
  - 减少子类生成
  - 将各colleague解耦
  - 简化对象协议
  - 对对象如何协作进行抽象
  - 使集中化 但中介本身可能难以维护
- 实现
  - 忽略抽象的mediator类 当同事类只有一个时，没必要定义一个抽象地mediator类 
  - colleague  事件发生时，colleague与mediator如何通信。将colleague作为observer，其他colleague作为subject。或者使用某种代理机制，colleague将自身作为参数传给mediator
- 应用
- 相关模式
  - facade 是对一个对象子系统进行抽象，协议是单向的
  - colleague可使用observer模式与mediator进行通信



## 5.6 memento

- 意图
  - 不破坏封装性的前提下，捕获一个对象的内部状态，在外部保存这个状态，这样对象就能被恢复为保存前的状态
- 别名
  - token
- 动机
  - 见意图
- 适用性
  - 见意图
  - 如果用接口来让其他对象直接得到信息，会暴露对象的实现细节，破坏对象的封装性
- 结构
  - 
- 参与者
  - memento
    - 存储原发器对象的内部状态，根据需要
    - 需要防止原发器以外的对象访问 两个接口，传递给其他对象与原发器对象的接口权限不同
  - originator
    - 原发器，用以创建一个备忘录，用以记录当前时刻的内部状态
    - 使用备忘录回复内部状态
  - caretaker
    - 负责保存好接口
    - 不能对备忘录的内容进行读取与操作
- 协作
  - caretaker请求备忘录，并将它保存一段时间后，送回给原发器
  - memento是被动的 只有创建memento的原发器会对他的状态进行赋值与检索
- 效果
  - 保持封装边界
  - 简化原发器
  - 内部状态的信息量和存取的频繁程度影响该模式消耗的资源
  - 定义 宽接口与窄接口
  - 维护备忘录的潜在代价
- 实现
  - 语言支持  c++:originator作为memento的友元，memento款接口为私有，窄接口为共有
  - 存储增量式改变 保存的memento状态是增量而非绝对值
- 实例
  - 图形移动的约束 命令被封装，具有执行和恢复功能；移动前由约束解释器保存状态，恢复前先移动约束解释器再恢复状态
- 应用
- 相关模式
  - command 命令可使用备忘录为可撤销的操作维护状态
  - iterator 备忘录可用于迭代



## observer

- 意图
  - 定义对象间的一种一对多的依赖关系，当一种对象的状态发生改变时，所有依赖于他的对象都将发生变化
- 别名
  - dependent publish-subscribe 
- 动机
  - 目标/观察者（subject/observer），一旦目标的状态发生改变，所有的观察者都得到通知
- 适用性
  - 一个抽象模型有两个部分，一个部分依赖于另一部分 两个部分封装在不同的对象中
  - 一个对象的改变需要同时改变其他对象，其他对象的数量位置
  - 对象不知道依赖他的是哪种对象
- 结构
- 参与者
  - subject 
    - 目标知道他的观察者，但是数量是动态变化的
    - 提供注册于删除观察者对象的接口
  - observer
    - 为获取来着subject的通知，需要定义一个更新接口
  - concretesubject
    - 将有关信息存入各concreteobserver对象
    - 当他的状态发生改变时，向他的各个观察者发出通知
  - concreteobserver
    - 维护一个指向concretesubject的引用
    - 存储有关状态，这些状态于目标状态尽量一致
    - 实现observer的更新接口，已使自身状态与目标状态保持一致
- 协作
  - concretesubject发生任何可能导致其观察者与其本身状态不一致的改变时，将通知其各个观察者
  - 在得到具体目标的改变通知后，concreteobserver将查询，以维护一致性
- 效果
  - 目标与观察者的抽象耦合 耦合不是具体的，也不紧密
  - 支持广播通信 随时增加观察者
  - 意外的更新 需要有一定的准则定义观察和更新行为
- 实现
  - 创建目标到其观察者之间的映射 较少时可以显示地维护对观察者地引用；观察者较多时，用一个关联查找表进行维护
  - 观察多个目标  更新接口需要目标告知身份 
  - 谁触发更新
  - 对已删除目标的悬挂引用
  - 在发出通知前确保自身状态一致 因为observer可能在更新时会会查询subject地状态
  - 避免特定于观察者地更新协议 推/拉模型，向每个对象发出尽可能详细的信息/向每个对象发出尽可能少的信息，然后由各个观察者去请求特定地数据
  - 指定感兴趣的事件，注册观察对象时指定感兴趣的事件，当感兴趣的事件发生时才通知该对象
  - 封装复杂的更新的语义
- 实例
- 应用
- 相关模式
  - mediator 通过封装复杂的更新语义，充当目标和观察者的中介者
  - singleton 唯一且可以全局访问



## 5.8 state

- 意图

  - 允许一个对象在内部对象改变时改变它的行为

- 别名

  - 状态对象 objects for state

- 动机

  - tcpconnection 不同的连接状态有不同的行为，将所有与状态相关的请求委托给这个类。不同的状态对象继承于同一个父类

- 适用性

  - 一个对象的行为取决于他的状态，并且必须在运行时刻依据状态更改他的行为
  - 一个操作中含有多分支的条件语句，这些分支依赖于对象的状态，state模式将对象自身的情况放入一个独立的类中

- 结构

- 参与者

  - context
  - state
  - concretestate 状态子类

- 协作

  - context将与状态相关的请求委托给当前的concreteState对象处理
  - Context将自身作为参数传递给状态对象，使状态对象在必要时可以对context进行访问
  - context是客户主要使用的接口。 客户可用状态对象来配置一个context，一旦context配置完毕，他的客户不再需要直接与状态对象交互
  - context或concretestate都可决定状态的切换

- 效果

  - 将与特定状态相关的行为局部化，将不同状态的行为分割开来
  - 将状态 转换显示化
  - state对象可被共享

- 实现

  - 谁定义状态切换 context或concretestate
  - 基于表的另一种方法 可以通过数据而不死程序数据该改变状态转换的规则性
    - 对表的查找通常不如虚函数调用效率高 
    - 用统一的、表格的形式表示转换准则，使得难以被理解
    - 难以加入一些伴随状态转换的一些动作
  - 创建和销毁State对象
    - 使用创建，用后立即销毁还是始终保持取决于使用频率与存储消耗的资源决定
  - 使用动态继承
    - c++不行

- 实例

  - tcpconnect 

    - 将几种连接状态封装为类，每个对象内保存唯一的状态，切换由tcpconnection进行控制

    - 每个连接状态是singleton，处理操作时，携带tcpconnect对象的指针

- 应用

- 相关模式

  - flyweight 如何共享状态对象
  - 状态对象通常是singleton



## 5.9 strategy 

- 意图

  - 封装算法，使他们可以相互替换

- 别名

  - policy

- 动机

  - 将算法硬编码进一个类中是不可取的
    - 直接包含算法代码庞大且难以维护
    - 不同的环境下希望使用不同算法
    - 增加或修改算法的便捷程度

- 适用性

  - 需要使用一个算法的不同变体
  - 算法使用客户不该知道的 数据
  - 一个类定义了多种行为，将相关的分支条件移入各自的strategy

- 结构

  - strategy
  - concretestrategy
  - context

- 参与者

- 协作

  - stragegy与context相互作用以实现选定算法 必要时context可以作为参数传入context

  - context将客户请求传递给strategy.客户可以选择一系列的concretestrategy中的一个

    

- 效果

  - 算法柯重用
  - 替代继承，使对象易于切换/理解/拓展
  - 避免一些条件选择
  - 实现的选择 空间/事件的取舍
  - 客户必须了解不同的strategy
  - 增加了应用中对象的数量

- 实现

  - 定义strategy和context接口 stragegy能够有效访问所需要的context中的任何数据
  - 将strategy作为模板参数
  - 使对象可选，还可以给定缺省的strategy

- 实例

- 应用

- 相关模式

  - flyweight strategy是很好的轻量级对象

## 5.10 template 

- 意图

  - 定义一个操作中的骨架，从而将一些步骤延迟到子类

- 别名

- 动机

  - 

- 适用性

  - 一次性实现一个算法中不变的部分，将可变部分留给子类来实现
  - 各子类中的公共行为集中到一个公共父类中以避免代码重复
  - 控制子类拓展

- 结构

  - abstract
    - 算法的骨架
  - concreteclass
    - 

- 参与者

  - 

- 协作

  - concreteclass依靠abstractClass实现原语操作来实现算法中不变的步骤

- 效果

  - 代码复用的基本技术 提取类库中的公共行为

  - 反向的控制结构 父类调用子类的操作

    - 具体操作
    - 具体的abstractclass操作
    - 原语操作  必须被重定义
    - factory method 
    - 钩子操作  子类在必要时可以进行拓展，缺省时为空操作

    

- 实现

  - c++ 使用c++访问控制，定义模板方法调用的原语操作为protect，模板方法非虚成员函数
  - 尽量减少原语操作
  - 命名约定 加前缀以示区别

- 实例

- 应用

- 相关模式

  - FACTORYMETHOD 常被模板方法调用
  - strategy 模板算法改变算法的一部分

## 5.11 visitor 

- 意图
  - 作用于某对象结构中的各元素的操作。在不改变各元素的类的前提下定义作用于这些元素的新操作
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 实例
- 应用
- 相关模式

```
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 实例
- 应用
- 相关模式
```

