# 5 行为模式

- 算法和对象职责的分配
- 控制流， 联系方式
- 行为对象模式使用组合而不是继承 相互协作/相互联系/耦合关系/依赖关系/

封装行为并指派/





## 5.1 chain of responsibility 

- 意图
  
  - 使多个对象有机会处理请求，避免耦合关系。将对象连成链，并沿着链传递该请求，直到有对象处理该请求
- 别名
- 动机
  
  - 同上
- 适用性
  - 多个对象可以处理同一请求，运行时刻自动确定
  - 不明确指定接收者时，可以向多个对象中的一个提交请求
  - 处理请求的集合应被动态指定
- 结构
  
  - 后继者作为接一个接收者
- 参与者
  - handler
  - concretehandler
  - client 
- 协作
  
  - 当客户提交一个请求时，请求沿链传递直至由一个concretehandler对象负责处理它
- 效果
  - 降低耦合度
  - 增强对象指派任务的灵活性
  - 不保证被接受
- 实现
  - 实现后继者链  
  - 连接后继者 转发给后继者 
  - 表示请求 定义请求的类型和处理方法，及请求者与处理者如何达成一致 （标示符与请求提供标示符函数）；子类可以通过重定义该函数拓展操作
- 实例
- 应用
- 相关模式

- 其他：

  - 职责链模式不由自身创建，而是由客户端进行设置
  - 一般的解决方法是边界各个层次的函数进行处理，需要修改时需要修改原代码，违反开闭原则

  

## 5.2 command 

- 意图
  - 将请求封装为对象，用不同的请求对客户进行参数化
- 别名
  - action transaction
- 动机
  - 接收者知道信息，该信息（可能是函数）是执行命令所需要的，将命令作为参数传入
  - 设计用户界面时具有很大灵活性
- 适用性
  - 抽象出待执行的行为以参数化某对象 回调函数面向对象的替代品
  - 在不同时刻指定、排列和执行请求
  - 支持取消操作
  - 支持修改日志
  - 用构建在原语基础上的高层操作构造一个系统   支持事务，易于拓展，添加新事务
- 结构
  - 支持取消操作
- 参与者
  - command 
  - concreteCommand
  - client
  - invoker
  - receiver
- 协作
  - client创建一个concreteCommand并指定他的receiver
  - invoker存储concretecommand对象
  - invoker提交请求，若命令可撤销，在执行之前
- 效果
  - 将操作对象 与 实现该操作对象向解耦   （？行为与信息分离）
  - 操作对象可与其他对象一样被操纵和拓展
  - 多个命令装配成一个复合命令
- 实现
  - 命令对象的智能程度 
  - 支持取消和操作  此时command需要记录额外的信息
  - 避免取消操作过程中的错误积累
  - 使用c++模板
- 实例
- 应用
  - 结合chain of responsibility，消费链
  - 命令的对象被计算出来，优化方法
- 相关模式
  - composite实现宏命令
  - memento 

## 5.3 interpreter 

- 意图
  - 给定语句，定义文法的一种表示，解释器解释该语句
- 别名
  - 
- 动机
  - 某种类型的问题发生频率足够高，将各个实例表述为简单语言中的句子。这样就可以通过解释这个句子来解决问题
- 适用性
  - 当有一个语言需要执行，并可以将该语言中的句子表示为一个抽象语法树，可使用解释器模式
  - 闻法简单
  - 效率不关键 最高效的解释器不直接解释语法分析树，而是首先转换成另外一种形式（状态机）
- 结构
- 参与者
  - abstractExpression 抽象表达式，声明一个抽象的解释操作
  - TerminalExpression 终结符表达式
  - NonterminalExpression 非终结符表达式
  - Context  上下文 
  - Client  客户
- 协作
  - client构建一个句子，初始化上下文，调用解释操作
  - 每一非终结符表达式定义相应子表达式的解释操作。各终结符表达式的解释操作构成递归的基础
  - 每一节点的解释操作用上下文来存储和访问解释器的状态
- 效果
  - 易于改变和拓展文法
  - 易于实现文法
  - 复杂文法难以维护   每条规则至少定义一个类，因此包含很多语法的文法可能难以管理和维护
  - 增加新的解释表达式的方法 若需要经常用新的方式解释表达式，则需要使用其他方式如访问者模式以避免修改这些表示文法的类
- 实现
  - 创建抽象语法树  不涉及语法分析，用语法分析程序/手写/client提供
  - 定义解释操作  并不需要在表达式中定义解释操作
  - 与Flyweight共享终结符 终结节点通常不保存位置信息，所需要的上下文信息由父节点传递给它们。用到了Flyeweight模式
- 实例
  - 通过lookup在预先设置的表上找到项与值，然后进行计算
- 应用
  - 大量使用，严格情况下，只有用一个类层次来定义某个语言时，才强调使用解释器模式
- 相关模式
  - composite:语法抽象树是复合模式的实例
  - Flyweight:说明了如何在抽象语法树中使用终结符



## 5.4 iterator 

- 意图

  - 提供一种按顺序访问一个聚合中的元素的方法，而不暴露内部表示

- 别名

  - cursor

- 动机

  - 见意图
  - 迭代器与列表分离，可以使用不同的遍历策略或者实现过滤规则

- 适用性

- 结构

- 参与者

  - iterator
  - concreteiterator 
  - aggregate
  - concreteaggregate

- 协作

  - 跟踪集合中的当前对象，能够计算出待遍历的后继对象

- 效果

  - 支持以不同方式遍历一个聚合

  - 简化了聚合的接口

  - 在同一各上可以同时由多个遍历 迭代器保存遍历状态

    

- 实现

  - 由谁控制迭代 外部迭代器/内部迭代器
  - 由谁实现遍历算法
  - 健壮性如何 保证插入和删除操作不会干扰遍历操作，且不需要拷贝该聚合
  - 附加的操作 
  - 在c++中使用多态迭代器 可能会删除出错
  - 迭代器可有特权访问 声明为protect ，其他迭台器继承该迭代器来进行拓展
  - 空迭代器 处理边界条件 

- 实例

  - 列表和迭代器接口
  - 迭代器子类的实现
  - 使用迭代器
  - 避免限定于一种特定的列表实现
  - 保证迭代器被删除 使用智能指针
  - 一个内部的ListIterator 由迭代器控制迭代，并对每个元素施行某个操作 传递全局函数；依赖于子类生成

- 应用

- 相关模式

  - composite iterator常用于复合结构
  - factorymethod:多态结构，通过factorymethod来实例化适当的迭代器子类

```
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 实例
- 应用
- 相关模式
```

