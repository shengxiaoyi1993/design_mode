# 4 结构型模式

- 涉及如何组合类和对象
- 并不对接口和实现进行组合，而是对对象进行组合实现新功能。区别于静态类组合
- 



## 4.1 adapter



- 意图

  - 转换接口

- 别名

  - wrapper

- 动机

  - 接口不匹配

- 适用性

  - 使用一个已存在类，但是接口不符合需求
  - 创建可复用类，适用于多种场景

- 结构

  - 类适配器：多重继承 ？
  - 对象适配器：继承一个，组合另一个

- 参与者

  - target

  - client

  - adaptee

  - adapter

    

- 协作

  - client调用adapter,adapter调用adaptee的操作实现这个请求

- 效果

  - 类适配器
    - 不能使用于一个类匹配一个父类和及其所有子类
    - 可重定义adaptee的部分接口
    - 仅引入了一个对象
  - 对象适配器
    - 同时适配一个父类和及其所有子类
    - 重定义adaptee的行为很麻烦
  - 其他因素
    - 接口的相似程度
    - 可插入的adapter
    - 使用双向匹配器提供提供透明操作
    - 双重继承

- 实现

  - 使用c++实现适配器类，adapter以共有方式继承target类，私有方式继承adaptee  ？
  - 可插入的适配器，
    - 使用抽象操作
    - 使用代理对象
    - 参数化的适配器

- 实例

  - 类适配器 多重继承，共有继承target,私有继承adaptee
  - 对象适配器 保存一个adaptee的对象，转换成对该对象的操作

- 应用

- 相关模式
  - bridge 刻意接口分离
  - decorator 增强其他对象的功能又不改变自身的接口，支持递归操作？
  - proxy 不改变接口的条件下，为一个对象定义了另一个对象



## 4.2 bridge

- 意图
  - 抽象部分与实现部分分离，使其可以独立地变化
- 别名
  - handle/body

- 动机
  - 继承机制的不足
    - 难以对抽象部分与实现部分进行独立的修改扩充和重用
    - 使用继承自同一抽象类的子类必须实现两个新类
    - 客户程序对实现有依赖性
- 适用性
  - 在程序运行时刻实现部分可以被选择或者切换
  - 类的抽象与实现部分都可以通过生成子类方法加以扩充。bridge模式可以针对不同的抽象接口和实现进行组合
  - 对一个抽象的实现部分对客户不产生影响，及客户代码不必重新编译
  - 对客户完全隐藏抽象的实现部分
  - 有许多类要生成，需要一定的层次结构将对象分解成两个部分
  - 
- 结构
- 参与者
  - Abstraction 
  - RefinedAbstraction
  - impletementor 
  - concreteimplementor 

- 协作
  - abstraction将client的请求转发给他的implementor对象
- 效果
  - 分离接口和实现
  - 提高可扩充性
  - 实现细节对于客户透明
- 实现
  - 仅有一个implementor没有必要创建一个抽象的implementor类
  - abstraction通过传入参数确定实例化哪一个类；也可以引入一个factory对象，作用是决定创建implementor类
  - 共享implmentor对象 多个对象之间共享实现
  - 多重继承机制 这种方法依赖于静态继承，无法实现真正的bridge模式
- 实例
  - 在abstraction类中有一个成员函数，负责生成implementor实例，可以是抽象工厂返回一个signleton 
- 应用
- 相关模式
  - abstractory factory模式可以用来创建和配置一个特定的bridge模式
  - adapter 用来帮助无关的类协同工作，通常在系统创建完成后适用，而bridge模式在系统创建时就使用



## 4.3 composite 

- 意图

  - 将对象组合成树形以表示“部分-整体”结构

- 别名

- 动机

  - 对象递归包含可能会定义元对象与容器对象来解决，但对两者的区别使用使程序更加复杂
  - 一个类同时具备管理自身与访问于管理子部件，因为具有相同接口使得可以进行多层次的递归调用

- 适用性

  - 表现对象的部分-整体层次结构
  - 忽略组合对象与单个对象的不同，使得可以统一使用组合结构中的所有对象

- 结构

- 参与者

  - component （图元）
    - 为组合中的对象声明接口 
  - leaf 
    - 叶对象没有子节点
    - 定义图元对象的行为
  - composite 
    - 定义有子部件的那些部件的行为
    - 存储子部件
  - client 
    - 通过component接口操作组合部件的对象

- 协作

  - client使用component类接口与组合中的对象进行交互，若接收者是也节点，则直接处理请求；若接收者是composite，则通常将操作发给子部件，同时执行一些辅助操作

- 效果

  - 包含基本对象与组合对象的类层次结构，基本对象与组合对象可以相互替代
  - 简化客户代码
  - 更容易添加新类型的组件
  - 使设计更加一般化 但是难以限制组合中的部件

- 实现

  - 显式的父部件引用 需要维护子部件的父部件，父部件的子部件信息的一致性
  - 共享组件 一个可行的解决方法是为子部件存储多个父部件，但是需要解决向父部件发送请求的冲突
  - 最大化component接口 尽可能的多定义一些公共操作，提供缺省的实现
  - 声明管理子部件的操作 是定义在component还是在composite中，透明性与安全性的抉择。根本的矛盾是企图对component与composite执行相同的操作，但是两者本来就有不同的行为
  - 是否给component实现一个component列表
  - 子部件排序  
  - 使用高速缓冲存驻改善性能 忽略无效操作
  - 删除component composite被删除时，最好由composite删除其子节点 ；除了共享子节点的情况
  - 存储component的数据结构 可以则有选择，实现可以不同

  

- 实例

  - 计算机的各个部件组装计算机 计算价格 

- 应用
- 相关模式
  - 通常用于responsibility of chain 
  - decorator 
  - flyweight 
  - itertor 
  - visitor 





## 4.4 decorator 

- 意图
  - 动态地给子类添加一些额外的职责
- 别名
  - 包装器wrapper
- 动机
  - 为某个对象而不是某个类添加功能
  - 将组建嵌入另一个对象，而且组件与对象地接口一致，能实现请求的转发；因此对用户透明
- 适用性
  - 不影响其它类的情况下，以动态、透明的方式给单个对象添加职责
  - 处理可以撤销的职责
  - 不能用生成子类的方法进行拓展 
- 结构
- 参与者
  - component
  - concretecomponent
  - decorator
  - concretedecorator
- 协作
  - 将请求转发给他的component对象，并在请求前后执行一些附加的操作
- 效果
  - 比静态继承更灵活
  - 避免在层次结构高层添加太多细节
  - decorator与他的component不一样 装饰了的和没有被装饰的；组件和被装饰者
  - 对于不熟悉系统的人，难以理解与维护
- 实现
  - 接口的一致性 decorator与component应继承于公共父类
  - 有时可以省略抽象decorator类
  - 保持component类的简单性
  - 改变对象外壳与改变对象内核 
    - decorator是改变外壳，组件不需要知道他的装饰物
    - stragegy则有所不同
- 实例
  - 被装饰物，作为参数传入装饰者并保存；调用装饰者时，装饰者同步调用被装饰物执行相同操作
- 应用
  - 调试布局时使用装饰类打印操作信息
  - 转发数据时，对数据进行解压
- 相关模式
  - adapter decorator改变对象的职责而不改变接口；adapter给对象全新的接口
  - composite 将一个组合退化为一个组件；decorator着重于添加额外的职责
  - strategy 





## 4.5 facade 

- 意图
  - 为子系统的一组接口提供一个一致的界面，facade定义了一个高层接口，使子系统更易使用
- 别名
- 动机
  - 将整个子系统视作一个对象，为这个对象定义接口。降低整个系统的复杂性
- 适用性
  - 子系统越加复杂，在使过程中产生分散的类，这些类使子系统具有重用性，但是对不需要重用的用户不友好。facade提供一个缺省的视图用于简单使用，需要定制的用户可以越过facade层
  - 构建层次结构的类时，用facade封装细节，仅通过facade进行通讯
- 结构
- 参与者
  - facade
  - subsystem classs
- 协作
  - facade对客户程序发送的请求转发给子系统对象，而不直接访问
- 效果
  - 客户系统使用子系统更加方便
  - 实现子系统与客户之间的松耦合关系
  - 不限制使直接用子系统类
- 实现
- 实例
- 应用
- 相关模式
  - abstract factory与facade一起使用可以提供一个接口



## 4.6 flyweight

- 意图
  - 运用共享技术支持大量的细粒度的对象
- 别名
- 动机
  - 有些程序采用对象技术，简单化的实现代价较大，大量对象的存在占用大量资源
  - 内部状态储存于flyweight中，可以共享（内部字符），而外部状态由环境决定不可共享（排版风格）
- 适用性  有效性取决于如何使用它及在何处使用它
  - 程序使用了大量对象
  - 完全由于大量对象造成的大量开销
  - 对象的大多数状态可变为外部状态
  - 可用较少的对象表示内部状态
  - 应用程序不依赖于对象标识
- 结构
  - 
- 参与者
  - flyweight 
  - concreteflyweight
  - unconcreteflyweight 
  - flyweightFactory
  - client
- 协作
  - flyweight所需的状态必定是内部或者外部的 client调用flyweight对象时，将该状态传给它
  - 用户不能直接对concretefactory类进行实例化，从而保证可以适当的共享
- 效果
  - 会增加传输、查找、计算时的开销
  - 会节省空间上的开销 用共享减少内部状态的消耗，用计算时间换取对外部状态的储存
- 实现
  - 删除外部对象 该模式的可用性取决于是否容易区分和隔离外部状态和内部状态
  - 管理共享对象 引用计数和垃圾回收
- 实例
- 应用
- 相关模式
  - 用flyweight实现state 与strategy



## 4.7 proxy

- 意图
  - 为其他对象提供一个代理，以控制对这个对象的访问
- 别名
  - surrogate
- 动机
  - 在确实需要一个对象时才有必要对他进行创建和初始化
  - 在一个文档中，并不需要显示所有图片，只有图片被draw时，才需要载入
  - 在需要用比较通用和复杂的对象指针代替简单的指针
- 适用性
  - 远程代理 请求编码与发送
  - 虚代理 缓存附加信息，延迟对实体的访问
  - 保护代理 权限管理
  - 智能指针
    - 引用计数
    - 计数开始与计数为0时
    - 使用锁定
- 结构
  - Proxy
  - subject
  - realsubject 
- 参与者
- 协作
  - 代理在适当的时间向实体转发请求
- 效果
  - 隐藏对象存在不同空间的事实
  - 优化处理，减少资源的消耗
  - 附加的事物处理 ，深浅拷贝
- 实现
  - 重载操作符
  - smalltalk
  - 不总是需要知道实体的类型 可以同一处理所有realsubject类
- 实例
  - 图像代理 知道必要的信息，图片尺寸
  - 
- 应用
- 相关模式
  - adapter 提供不同的接口，proxy提供的是相同的接口
  - decorator 为对象提供更多功能，proxy实现控制对象的访问



## 4.8 结构模式的讨论

### 4.8.1 adapter 与 bridge 

- adapter在已有类的基础上，bridge实现有多种实现的接口

### 4.8.2 composite decorator proxy 

- decorator着重于额外功能的实现
- composite着重于组合体作为整体进行操作
- proxy侧重于实体不方便直接访问或使用时采用间接的方法







```
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 实例
- 应用
- 相关模式
```

