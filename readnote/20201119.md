# 1 

- 设计不能一蹴而就
- 复用，经验
- 模式分类：创建型，结构型，行为型

## 1.1 什么是设计模式

- 不断发生的问题及其解决方案；特定场景下解决一般设计问题的类和相互通讯的对象的描述
- 基本要素：
  - 名称
  - 问题
  - 解决方案
  - 效果

## 1.2 smalltalk 中的mvc

- 解释

  - view屏幕上的表示
  - model：s应用对象
  - contrller：用户界面对用户输入的响应 
  - 特点：...

- 更一般
  - 将对象分离，使得该对象能够影响另一些对象而不需要知道被影响对象的细节

## 1.3 描述
- 图形符号（类的关系），设计模式的决定/选择/权衡过程
- 描述元素
  - 模式名和分类
  - 意图
  - 别名
  - 动机
  - 适用性
  - 结构
  - 参与者
  - 协作
  - 效果
  - 实现
  - 代码示例
  - 已知应用 
  - 相关模式 

## 1.4 设计模式的编目

## 1.5 组织编目
### 目的准则
- creational :与创建有关
- structural：类与对象的组合
- behavioral ：交互与分配职责

### 范围准则
- 适用于类  ：处理类与子类的关系，编译时已确定
- 适用于对象：运行时刻可以变化

## 1.6 设计模式解决设计问题
### 1.6.1 寻找合适的对象
- 对象包括数据与对数据进行操作的过程
- 客户请求-操作
- 分解与抽象；重组与实现

### 1.6.2 划分对象的粒度
- 不同设计模式可以不同粒度的对象

### 1.6.3 指定对象接口
- 接口与实现分离
- 接口与执行对象相关，动态绑定：允许在运行时刻替换由相同接口的对象（多态）

### 1.6.4 描述对象 的实现 

### 名词
- 成员 OMT
- 实例化
- 继承 
- 抽象类（为子类提供公共接口，部分或全部实现延迟到子类）/具体类
- 重定义
- 混入类（mixin class）提供可供选择的借口或者功能的类

### 比较
- 类继承与接口继承
  - 对象的类（与实现相关）与对象的类型（与接口相关），c++不进行显示区分
- <>对接口编程，而非对实现编程
  - 创建者模式确保系统是通过针对接口方式编写的而非针对接口的方式编写的

### 1.6.5 运用复用机制
- 1 继承与组合的比较 白箱复用/黑箱复用
  - 继承
    - 编译时刻静态定义
    - 便于改变复用的实现
    - 无法改变从父类继承的实现；定义了子类的部分表示；解释了父类的实现细节；被继承的下来的实现不利于解决新的问题，父类就必须重写?
  - 组合
    - 使更重视接口设计；通过接口访问，不破坏封装型；实现上依赖较少；保证每个类被封装
    - 
  <>优先使用组合，而不是类继承
  
- 2 委托
  - 组合方法，使组合具有与继承一样的复用能力
    - 委托者将操作委托给代理者进行处理，同时将子集传给代理人，使得被委托的操作可以引用接收请求者的对象
    - 优点是：便于在运行时刻操作及改变操作的组合方式 

- 3 继承与参数化类型
  模板方法
  
  
### 1.6.6 关联运行时刻与编译时刻的结构
- aggregation ：相同的声明周期
- acquaintance ：请求彼此的操作，松散的请求关系
- 取决于设计而非语言机制

### 1.6.7 设计应支持变化 
- 未曾预料到的变化代价巨大
- 重新设计的一般原因
  - 显示地指定一个类来创建对象：间接地创建对象
  - 对特殊操作的依赖：便于改变响应请求的方法
  - 对硬件或软件平台的依赖：设计系统时限制平台相关性
  - 对对象表示或者实现 的依赖：对客户隐藏这些信息
  - 算法依赖：可能发生改变的算法应该被孤立出来
  - 紧耦合：使用抽象耦合和分层技术提高系统的松散耦合性
  - 通过生成子类来扩充功能：设计子类与已存在的子类进行组合来引入新的功能
  - 类难以修改：使用某些设计模式

- 三类程序地设计
  - 应用程序
  - 库
  - 框架 设计模式更抽象，更宏观，更具有一般意义
  
## 1.7 怎样选择设计模式
## 1.8 怎样使用设计模式

- 看本书